// Copyright 2018 The Bazel Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import * as vscode from "vscode";

import { BazelWorkspaceInfo, QueryLocation } from "../bazel";
import { getTargetsForBuildFile } from "../bazel";
import {
  getDefaultBazelExecutablePath,
  areBazelQueriesEnabled,
} from "../extension/configuration";
import { blaze_query } from "../protos";
import { CodeLensCommandAdapter } from "./code_lens_command_adapter";

/**
 * Groups of Bazel targets organized by the actions they support.
 * Used by the CodeLens provider to determine which actions to display for each target.
 *
 * @interface ActionGroups
 * @property {string[]} copy - Targets that support copying their label to clipboard (all target types)
 * @property {string[]} build - Targets that support build operations (libraries, binaries, tests)
 * @property {string[]} test - Targets that support test execution (test rules only)
 * @property {string[]} run - Targets that support run operations (executable binaries only)
 */
interface ActionGroups {
  copy: string[];
  build: string[];
  test: string[];
  run: string[];
}

/** Provides CodeLenses for targets in Bazel BUILD files. */
export class BazelBuildCodeLensProvider implements vscode.CodeLensProvider {
  public onDidChangeCodeLenses: vscode.Event<void>;

  /** Fired when BUILD files change in the workspace. */
  private onDidChangeCodeLensesEmitter = new vscode.EventEmitter<void>();

  /**
   * Initializes a new CodeLens provider with the given extension context.
   *
   * @param context The VS Code extension context.
   */
  constructor(private context: vscode.ExtensionContext) {
    this.onDidChangeCodeLenses = this.onDidChangeCodeLensesEmitter.event;

    const buildWatcher = vscode.workspace.createFileSystemWatcher(
      "**/{BUILD,BUILD.bazel}",
      true, // ignoreCreateEvents
      false,
      true, // ignoreDeleteEvents
    );
    buildWatcher.onDidChange(
      () => {
        this.onDidChangeCodeLensesEmitter.fire();
      },
      this,
      context.subscriptions,
    );

    vscode.workspace.onDidChangeConfiguration((change) => {
      if (
        change.affectsConfiguration("bazel.enableCodeLens") ||
        change.affectsConfiguration("bazel.enableQueries")
      ) {
        this.onDidChangeCodeLensesEmitter.fire();
      }
    });
  }

  /**
   * Provides promisified CodeLen(s) for the given document.
   *
   * @param document A Bazel BUILD file
   * @param token CodeLens token automatically generated by VS Code when
   * invoking the provider
   */
  public async provideCodeLenses(
    document: vscode.TextDocument,
  ): Promise<vscode.CodeLens[]> {
    const bazelConfig = vscode.workspace.getConfiguration("bazel");
    const enableCodeLens = bazelConfig.get<boolean>("enableCodeLens");
    if (!enableCodeLens) {
      return [];
    }

    if (!areBazelQueriesEnabled()) {
      return [];
    }

    if (document.isDirty) {
      // Don't show code lenses for dirty BUILD files; we can't reliably
      // determine what the build targets in it are until it is saved and we can
      // invoke `bazel query` with the updated file.
      return [];
    }

    const workspaceInfo = BazelWorkspaceInfo.fromDocument(document);
    if (workspaceInfo === undefined) {
      // Not in a Bazel Workspace.
      return [];
    }

    const queryResult = await getTargetsForBuildFile(
      getDefaultBazelExecutablePath(),
      workspaceInfo.bazelWorkspacePath,
      document.uri.fsPath,
    );

    return this.computeCodeLenses(workspaceInfo, queryResult);
  }

  /**
   * Takes the result of a Bazel query for targets defined in a package and
   * returns a list of CodeLens for the BUILD file in that package.
   *
   * @param bazelWorkspaceInfo The Bazel workspace information containing workspace path and context
   * @param queryResult The result of the bazel query containing target definitions
   * @returns A new array of CodeLens objects for the BUILD file
   */
  private computeCodeLenses(
    bazelWorkspaceInfo: BazelWorkspaceInfo,
    queryResult: blaze_query.QueryResult,
  ): vscode.CodeLens[] {
    const result: vscode.CodeLens[] = [];

    // Sort targets alphabetically
    const sortedTargets = [...queryResult.target].sort((a, b) => {
      return a.rule.name.localeCompare(b.rule.name);
    });

    // Group targets by line number to handle multiple targets on same line
    const targetsByLine = new Map<number, typeof sortedTargets>();
    for (const target of sortedTargets) {
      const location = new QueryLocation(target.rule.location);
      const line = location.line;
      if (!targetsByLine.has(line)) {
        targetsByLine.set(line, []);
      }
      targetsByLine.get(line)?.push(target);
    }

    // Process each line's targets
    for (const [, targets] of targetsByLine) {
      this.createCodeLensesForTargetsOnSameLine(
        targets,
        bazelWorkspaceInfo,
        result,
      );
    }

    return result;
  }

  /**
   * Creates CodeLens objects for targets on the same line.
   *
   * @param targets Array of Bazel targets found on the same line in the BUILD file
   * @param bazelWorkspaceInfo Workspace context information for command creation
   * @param result Output array that will be modified in-place to include new CodeLens objects
   */
  private createCodeLensesForTargetsOnSameLine(
    targets: blaze_query.ITarget[],
    bazelWorkspaceInfo: BazelWorkspaceInfo,
    result: vscode.CodeLens[],
  ): void {
    const location = new QueryLocation(targets[0].rule.location);

    const actionGroups = this.groupTargetsByAction(targets);

    this.createCodeLens(
      "Copy",
      "bazel.copyLabelToClipboard",
      actionGroups.copy,
      location,
      bazelWorkspaceInfo,
      result,
    );
    this.createCodeLens(
      "Build",
      "bazel.buildTarget",
      actionGroups.build,
      location,
      bazelWorkspaceInfo,
      result,
    );
    this.createCodeLens(
      "Test",
      "bazel.testTarget",
      actionGroups.test,
      location,
      bazelWorkspaceInfo,
      result,
    );
    this.createCodeLens(
      "Run",
      "bazel.runTarget",
      actionGroups.run,
      location,
      bazelWorkspaceInfo,
      result,
    );
  }

  /**
   * Groups targets by the actions they support based on Bazel rule types.
   * Uses rule naming conventions to determine which actions are available.
   *
   * @param targets Array of Bazel targets to classify by supported actions
   * @returns ActionGroups object with targets organized by action type
   */
  private groupTargetsByAction(targets: blaze_query.ITarget[]): ActionGroups {
    const copyTargets: string[] = [];
    const buildTargets: string[] = [];
    const testTargets: string[] = [];
    const runTargets: string[] = [];

    for (const target of targets) {
      const targetName = target.rule.name;
      const ruleClass = target.rule.ruleClass;

      // All targets support copying and building
      copyTargets.push(targetName);
      buildTargets.push(targetName);

      // Only test targets support testing.
      if (ruleClass.endsWith("_test") || ruleClass === "test_suite") {
        testTargets.push(targetName);
      }

      // Targets which are not libraries may support running.
      //
      // Without checking the Bazel rule's `executable` attribute we can't know
      // for sure which targets can be run. This could be calculated by running
      // `bazel cquery`, but this would introduce significant costs due to
      // first running the `analysis` phase, so we use a heuristic instead.
      const ruleIsLibrary = ruleClass.endsWith("_library");
      if (!ruleIsLibrary) {
        runTargets.push(targetName);
      }
    }

    return {
      copy: copyTargets,
      build: buildTargets,
      test: testTargets,
      run: runTargets,
    };
  }

  /**
   * Creates a CodeLens for a specific action type if targets are available.
   * Title shows action name with count for multiple targets.
   *
   * @param actionName Display name for the action (e.g., "Build", "Test", "Run", "Copy")
   * @param command VS Code command identifier to execute when CodeLens is clicked
   * @param targets Array of target names that support this action
   * @param location Source location information for CodeLens positioning
   * @param bazelWorkspaceInfo Workspace context for command adapter creation
   * @param result Output array that will be modified in-place to include the new CodeLens
   */
  private createCodeLens(
    actionName: string,
    command: string,
    targets: string[],
    location: QueryLocation,
    bazelWorkspaceInfo: BazelWorkspaceInfo,
    result: vscode.CodeLens[],
  ): void {
    if (targets.length === 0) {
      return;
    }

    const title =
      targets.length === 1 ? actionName : `${actionName} (${targets.length})`;

    result.push(
      new vscode.CodeLens(location.range, {
        arguments: [new CodeLensCommandAdapter(bazelWorkspaceInfo, targets)],
        command,
        title,
        tooltip: `${actionName} target - ${targets.length} targets available`,
      }),
    );
  }
}
